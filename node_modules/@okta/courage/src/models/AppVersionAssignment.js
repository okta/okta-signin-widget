/* eslint max-depth: [2, 4], max-statements: [2, 14], complexity: [2, 7] */
define([
  'jquery', 'underscore', 'shared/util/TemplateUtil', 'shared/models/BaseModel', 'shared/models/Org'
], function ($, _, TemplateUtil, BaseModel, Org) {

  var urlTemplate, Assignment;

  urlTemplate = TemplateUtil.tpl(
    '/api/internal/apps/{{appId}}/appVersions/{{versionId}}/assignment'
  );

  Assignment = BaseModel.extend({

    defaults: {
      isDefault: false,
      wasDefault: false,
      orgs: null,

      // FIX ME: Think more about the error framework later. Should this
      // be on the model? Should it be a state? Questions.
      assignmentError: null
    },

    initialize: function (attrs, options) {
      this.options = options || {};
      this.initCommitRevert();
      // Changing to default clears out orgs on the backend.
      this.on('change:isDefault', function (model, isDefault) {
        var orgs = isDefault ? [] : this._origState.orgs;
        this.get('orgs').reset(orgs);
      }, this);

    },

    toJSON: function () {
      var json = BaseModel.prototype.toJSON.call(this);
      if (json.orgs && json.orgs.toJSON) {
        json.orgs = json.orgs.toJSON();
      }
      delete json.assignmentError;
      return json;
    },

    // Assignment is a little weird in that it's an update (PUT) but there's
    // no id associated with the model (or rather, the API signature is
    // different). So we'll override it this way.
    sync: function (method, model, options) {
      if (method === 'create') {
        method = 'update';
      }
      return BaseModel.prototype.sync.call(this, method, model, options);
    },

    parse: function (resp) {
      resp.assignmentError = false;
      // FIX ME: The server sends a non-empty object back on successful
      // assignment, which we need to clear. Can take this out when fixed.
      resp.orgs = new Org.Collection(resp.orgs);

      // Simulates events when changing orgs. Note: This is the same problem
      // as found in AppVersion with Assignment. Better solution is to
      // check if orgs exist and modify accordingly
      this.listenTo(resp.orgs, 'add remove reset', function () {
        // Note: Modifies changed property, which is a no-no in the backbone
        // docs. It's okay if we understand what's going on.
        this.changed.orgs = this.get('orgs').clone();
        this.trigger('change:orgs', this, this.changed.orgs);
        this.trigger('change', this);
      });

      return resp;
    },

    // FIX ME: This is the dirty, fast way of representing the migration. Once
    // we get more types, let's actually do this the right way (break
    // out into its own set of collections/models)
    set: function (key, val, options) {
      var tokens, clone, obj, part;
      // Doesn't support key that is a key/val hash
      if (typeof key !== 'object') {
        tokens = key.split('.');
        if (tokens.length > 1) {
          key = tokens.shift();
          obj = clone = $.extend(true, {}, this.get(key));
          while ((part = tokens.shift()) !== undefined) {
            if (!obj[part]) { obj[part] = {}; }
            if (tokens.length === 0) { obj[part] = val; }
            obj = obj[part];
          }
          val = clone;
        }
      }
      return BaseModel.prototype.set.call(this, key, val, options);
    },

    // Commit/Revert functions
    initCommitRevert: function () {
      this.commit({ force: true, silent: true });
      this.on('sync', function () {
        this.commit({ force: true });
      });
      this.on('change', function (model) {
        var changed = model.changedAttributes();
        if (changed.orgs) {
          changed.orgs = changed.orgs.toJSON();
        }
        this._changedProperties = _.extend(
          this._changedProperties,
          changed
        );
      }, this);
    },

    // Revert to last 'commit' - server sync (or initialize) state.
    // Useful for forms where the user might click cancel - use model.set()
    // to update properties when input fields change, and revert in the
    // event of a cancel.
    revert: function () {
      if (_.isEmpty(this._changedProperties)) {
        return;
      }
      if (this._changedProperties.orgs) {
        this.get('orgs').reset(this._origState.orgs);
        delete this._changedProperties.orgs;
      }
      if (this._changedProperties.assignmentError) {
        this.set('assignmentError', false); // doesn't show up in toJSON
      }
      this.set(_.pick(this._origState, _.keys(this._changedProperties)));
      this._changedProperties = {};
    },

    // Normally only triggered automatically on server sync or initialize.
    // Can be used to manually set the state the revert() goes back to.
    commit: function (options) {
      var orig, changed, attr, prev;
      orig = this._origState || {};
      changed = this._changedProperties || {};
      options = options || {};
      if (!_.isEmpty(changed) || options.force) {
        this._changedProperties = {};
        this._origState = this.toJSON();
        if (!options.silent) {
          attr = _.clone(changed);
          prev = _.pick(orig, _.keys(attr));
          this.trigger('commit', this, { prev: prev, attr: attr });
        }
      }
    },

    url: function () {
      return urlTemplate({
        appId: this.options.appId,
        versionId: this.options.versionId
      });
    }

  });

  return Assignment;

});
