/* eslint max-depth: [2, 4], max-statements: [2, 14], complexity: [2, 6] */
define([
  'underscore', 'jquery', 'shared/models/BaseCollection', 'shared/models/BaseModel', 'shared/models/SamlAttribute'
], function (_, $, BaseCollection, BaseModel, SamlAttribute) {

  var BaseSignOnMode, BaseSamlSignOnMode, SignOnModes, SignOnMode = {};

  BaseSignOnMode = BaseModel.extend({

    // Overrides get/set to account for non-flat signOnMode. This is
    // necessary for properties like testAccounts. In the
    // future, these might go into their own collections/models and then
    // we can remove this logic

    get: function (attr) {
      var tokens, val;
      tokens = attr.split('.');
      val = BaseModel.prototype.get.call(this, tokens.shift());
      if (tokens.length > 0) {
        _.each(tokens, function (key) {
          if (!_.isUndefined(val)) {
            val = val[key];
          }
        });
      }
      return val;
    },

    set: function (key, val, options) {
      var tokens, clone, obj, part;

      // Doesn't support key that is a key/val hash
      if (typeof key !== 'object') {
        tokens = key.split('.');
        if (tokens.length > 1) {
          key = tokens.shift();
          obj = clone = $.extend(true, {}, this.get(key));
          while ((part = tokens.shift()) !== undefined) {
            if (!obj[part]) { obj[part] = {}; }
            if (tokens.length === 0) { obj[part] = val; }
            obj = obj[part];
          }
          val = clone;
        }
      }
      return BaseModel.prototype.set.call(this, key, val, options);
    },

    toJSON: function () {
      var json = BaseModel.prototype.toJSON.call(this);
      delete json.supported;
      return json;
    }

  });

  SignOnMode.AutoLogin = BaseSignOnMode.extend({
    defaults: function () {
      return {
        name: 'AUTO_LOGIN',
        type: 'AUTO_LOGIN',
        _signOnModeMediatedType: 'AUTO_LOGIN',
        externalDocURL: '',
        loginRedirectURL: '',
        anotherLoginURL: '',
        isDefault: false,
        testAccount: {},
        supported: true
      };
    }
  });

  SignOnMode.BasicAuth = BaseSignOnMode.extend({
    defaults: function () {
      return {
        name: 'BASIC_AUTH',
        type: 'BASIC_AUTH',
        _signOnModeMediatedType: 'BASIC_AUTH',
        authURL: '',
        loginRedirectURL: '',
        isDefault: false,
        testAccount: {},
        supported: true
      };
    }
  });

  SignOnMode.BrowserPlugin = BaseSignOnMode.extend({
    defaults: function () {
      return {
        name: 'BROWSER_PLUGIN',
        type: 'BROWSER_PLUGIN',
        _signOnModeMediatedType: 'BROWSER_PLUGIN',
        loginRedirectURL: '',
        siteFlowText: '',
        isDefault: false,
        testAccount: {},
        supported: true
      };
    }
  });

  SignOnMode.MobileNoSignOn = BaseSignOnMode.extend({
    defaults: function () {
      return {
        name: 'MOBILE_NO_SIGNON',
        type: 'MOBILE_NO_SIGNON',
        _signOnModeMediatedType: 'MOBILE_NO_SIGNON',
        isDefault: false,
        supported: true
      };
    }
  });

  SignOnMode.SecurePasswordStore = BaseSignOnMode.extend({
    defaults: function () {
      return {
        name: 'SECURE_PASSWORD_STORE',
        type: 'SECURE_PASSWORD_STORE',
        _signOnModeMediatedType: 'SECURE_PASSWORD_STORE',
        httpMethod: 'POST',
        postBackUrl: '',
        formFields: {},
        isDefault: false,
        testAccount: {},
        supported: true
      };
    },

    get: function (attr) {
      var tokens, val, baseToken;
      tokens = attr.split('.');
      baseToken = tokens.shift();
      val = BaseModel.prototype.get.call(this, baseToken);
      if (tokens.length > 0) {
        if (baseToken == 'formFields') {
          val = val[tokens.join('.')];
        } else {
          _.each(tokens, function (key) {
            if (!_.isUndefined(val)) {
              val = val[key];
            }
          });
        }
      }
      return val;
    },

    set: function (key, val, options) {
      var tokens, clone, obj, part, baseToken;

      // key will be something like formFields.[field name] where the field name can contain dots.
      // Transform into an object formFields whose attribute is the field name.
      if (typeof key !== 'object') {
        tokens = key.split('.');

        if (tokens.length > 1) {
          baseToken = tokens.shift();
          if (baseToken == 'formFields') {
            key = baseToken;
            obj = clone = $.extend(true, {}, this.get(key));
            part = tokens.join('.');
            obj[part] = val;
            val = clone;
          }
        }
      }
      return BaseModel.prototype.set.call(this, key, val, options);
    }
  });

  BaseSamlSignOnMode = BaseSignOnMode.extend({
    parse: function (resp) {
      if (resp.attributeStatement && _.isArray(resp.attributeStatement.attributes)) {
        resp.attributeStatement.attributes = new SamlAttribute.Collection(
          resp.attributeStatement.attributes, {parse: true});
      } else if (resp.attributeStatement && resp.attributeStatement.attributes instanceof SamlAttribute.Collection) {
        // This is for the case where we clone the model
        resp.attributeStatement.attributes = new SamlAttribute.Collection(
          resp.attributeStatement.attributes.toJSON(), {parse: true});
      } else {
        resp.attributeStatement = {
          attributes: new SamlAttribute.Collection()
        };
      }

      return resp;
    }
  });

  SignOnMode.Saml11 = BaseSamlSignOnMode.extend({
    defaults: function () {
      return {
        name: 'SAML_1_1',
        type: 'SAML_1_1',
        _signOnModeMediatedType: 'SAML_1_1',
        externalDocURL: '',
        postBackURL: '',
        loginRedirectURL: '',
        ipIssuer: '',
        spIssuerLookup: '',
        nameId: '',
        nameIdFormat: '',
        audienceRestriction: '',
        responseSigned: false,
        assertionSigned: false,
        attributeStatement: {},
        nameQualifier: '',
        recipient: '',
        isDefault: false,
        testAccount: {},
        supported: true
      };
    }
  });

  SignOnMode.Saml20 = BaseSamlSignOnMode.extend({
    defaults: function () {
      return {
        name: 'SAML_2_0',
        type: 'SAML_2_0',
        _signOnModeMediatedType: 'SAML_2_0',
        externalDocURL: '',
        postBackURL: '',
        loginRedirectURL: '',
        ipIssuer: '',
        spIssuerLookup: '',
        nameId: '',
        nameIdFormat: '',
        audienceRestriction: '',
        responseSigned: false,
        assertionSigned: false,
        attributeStatement: {},
        recipient: '',
        authnContextClassRef: '',
        destination: '',
        requestCompressed: false,
        isDefault: false,
        testAccount: {},
        supported: true,
        signatureAlgorithm: '',
        digestAlgorithm: '',
        assertionEncrypted: false,
        encryptionAlgorithm: '',
        keyTransportAlgorithm: '',
        forceAuthn: true
      };
    }
  });

  SignOnMode.Oidc = BaseSignOnMode.extend({
    defaults: function () {
      return {
        name: 'OPENID_CONNECT',
        type: 'OPENID_CONNECT',
        _signOnModeMediatedType: 'OPENID_CONNECT',
        isDefault: false,
        supported: true
      };
    }
  });

  SignOnMode.Unsupported = BaseSignOnMode.extend({
    defaults: {
      supported: false
    }
  });

  SignOnModes = BaseCollection.extend({

    // The SignOnModes collection is special since it can have different types
    // of models. This allows us to pass in a json object and still have it map
    // to the correct model.
    model: function (attrs, options) {
      var Mode = _.find(SignOnMode, function (m) {
        return _.result(m.prototype, 'defaults').type === attrs.type;
      });
      if (!Mode) {
        Mode = SignOnMode.Unsupported;
      }
      options.parse = true;
      return new Mode(attrs, options);
    },

    // Helper function to return supported SignOnMode types that do not exist
    // in this collection.
    getMissingSignOnModeTypes: function () {
      return _.difference(
        _.chain(SignOnMode)
          .map(function (m) { return _.result(m.prototype, 'defaults'); })
          .filter(function (d) { return d.supported; })
          .map(function (d) { return d.type; })
          .value(),
        this.pluck('type')
      );
    },

    // Only return supported signOnModes because server is not
    // expecting them. This has the happy(ish) side effect of not adding
    // unsupported signOnModes to the clone which is used for creating
    // a new version
    toJSON: function () {
      var json = {};
      this.each(function (model) {
        json[model.get('name')] = model.toJSON();
      });
      return json;
    }

  });

  return {
    model: SignOnMode,
    collection: SignOnModes
  };

});

