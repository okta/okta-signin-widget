/* eslint complexity: [2, 9], max-statements: [2, 23], max-params: [2, 15] */
define([
  'underscore',
  'shared/util/TemplateUtil',
  'shared/models/BaseCollection',
  'shared/models/BaseModel',
  'shared/models/SignOnMode',
  'shared/models/AppVersionAssignment',
  'shared/models/EnumType',
  'shared/models/CustomType',
  'shared/models/AppInstanceProperty',
  'shared/models/AppUserProperty',
  'shared/models/MobileApp',
  'shared/models/SessionAuthMode',
  'shared/models/ScimProperties',
  'shared/models/AppLink',
  'shared/models/HelpTextValue'
], function (
  _, TemplateUtil, BaseCollection, BaseModel, SignOnMode, AppVersionAssignment, EnumType, CustomType,
  AppInstanceProperty, AppUserProperty, MobileApp, SessionAuthMode, ScimProperties, AppLink, HelpTextValue
) {

  // Helper
  function parseCollection(collection, type) {
    if (collection instanceof type.Collection) {
      return new type.Collection(collection.toArray());
    } else if (collection instanceof Array) {
      return new type.Collection(collection);
    } else {
      return new type.Collection();
    }
  }

  var urlVerify = TemplateUtil.tpl('/api/internal/apps/{{appId}}/' +
                                   'appVersions/{{versionId}}/verification/{{status}}');

  var AppVersion, AppVersions;

  AppVersion = BaseModel.extend({

    defaults: {
      id: null,
      appId: null,
      appName: null,
      comment: null,
      title: null,
      assignment: null,
      signOnModes: null,
      displayName: null,
      isPrivate: null,
      supportLevel: null,
      userManagementFeatures: null,
      toolbarSupported: null,
      connectorDriven: null,
      agentDriven: null,
      clientAppId: null,
      urlRegex: null,
      verificationStatus: 'NEW',
      enumTypes: null,
      customTypes: null,
      appInstanceProperties: null,
      appUserProperties: null,
      sourceVersionId: null,
      mobileApps: null,
      helpTextValues: null,

      // Convenience properties for getting isDefault & wasDefault
      'assignment.isDefault': function () {
        return this.get('assignment').get('isDefault');
      },
      'assignment.wasDefault': function () {
        return this.get('assignment').get('wasDefault');
      },
      // Number of orgs assigned
      'assignment.orgCount': function () {
        return this.get('assignment').get('orgs').length;
      },

      // Let's us know on the assignment page if we're coming from create
      inCreateFlow: false

    },

    initialize: function (attrs, options) {
      this.options = options || {};
      // Don't care about BaseModel change event right now (and it
      // currently doesn't work if we don't call ComputedProperty
      // on our function
      //BaseModel.prototype.initialize.apply(this, arguments);
    },

    toJSON: function () {
      var json = BaseModel.prototype.toJSON.call(this);
      json.signOnModes = json.signOnModes.toJSON();
      json.appLinks = json.appLinks.toJSON();
      json.enumTypes = json.enumTypes.toJSON();
      _.each(json.enumTypes, function (e, i) {
        json.enumTypes[i].values = e.values.toJSON();
      });
      json.customTypes = json.customTypes.toJSON();
      _.each(json.customTypes, function (e, i) {
        json.customTypes[i].properties = e.properties.toJSON();
      });
      json.appInstanceProperties = json.appInstanceProperties.toJSON();

      json.appUserProperties = json.appUserProperties.toJSON();

      json.mobileApps = json.mobileApps.toJSON();

      json.assignment = json.assignment.toJSON();

      json.sessionAuthModes = json.sessionAuthModes.toJSON();

      if (json.scimProperties) {
        json.scimProperties = json.scimProperties.toJSON();
      }

      json.helpTextValues = json.helpTextValues.toJSON();

      delete json.inCreateFlow;
      return json;
    },

    // Bubble down commit event from collection
    commit: function (options) {
      this.get('assignment').commit(options);
    },

    parse: function (resp) {
      // FIX ME: Ask Nidhi to change signOnModes to array (it's an object now)
      // We can then get rid of some of the following logic.
      var ssoArray = [];
      _.each(resp.signOnModes, function (mode) {
        ssoArray.push(mode);
      });
      resp.signOnModes = new SignOnMode.collection(ssoArray);
      resp.assignment = new AppVersionAssignment(resp.assignment, {
        parse: true,
        versionId: resp.id,
        appId: resp.appId
      });
      // We need to put this here (vs. in initialize) because saving
      // wipes the assignment out, but doesn't call initialize again.
      // A better way in the future would be to not wipe it out - check if
      // it exists and then set new properties on it. Need to worry about
      // orgs in AppVersionAssignment though (same logic applies there)
      this.listenTo(resp.assignment, 'commit', function (m, changes) {
        this.trigger('commit', this, changes);
      });

      // Parse AppLinks
      resp.appLinks = parseCollection(resp.appLinks, AppLink);

      // parse enumTypes
      resp.enumTypes = parseCollection(resp.enumTypes, EnumType);

      // parse customTypes
      resp.customTypes = parseCollection(resp.customTypes, CustomType);

      // parse appInstanceProperties
      resp.appInstanceProperties = parseCollection(resp.appInstanceProperties, AppInstanceProperty);

      // parse appUserProperties
      resp.appUserProperties = parseCollection(resp.appUserProperties, AppUserProperty);

      //Mobile apps
      resp.mobileApps = new MobileApp.Collection(resp.mobileApps);

      var sessionAuthModesArray = [];
      _.each(resp.sessionAuthModes, function (mode) {
        sessionAuthModesArray.push(new SessionAuthMode.Model(mode));
      });
      resp.sessionAuthModes = new SessionAuthMode.Collection(sessionAuthModesArray);

      if (resp.scimProperties) {
        resp.scimProperties = new ScimProperties.Model(resp.scimProperties);
      }

      resp.helpTextValues = new HelpTextValue.Collection(resp.helpTextValues);

      return resp;
    },

    url: function () {
      if (this.get('__inVerifyFlow__')) {
        return urlVerify({
          appId: this.get('appId'),
          versionId: this.get('id'),
          status: this.get('verificationStatus')
        });
      } else {
        return '/api/internal/apps/' + this.get('appId') + '/appVersions';
      }
    }

  });

  AppVersions = BaseCollection.extend({

    model: AppVersion,

    // On a commit event, propagate changes to other models that
    // are dependent on that change.
    initialize: function (models, options) {
      this.options = options || {};
      this.on('commit', function (model, changes) {
        if (changes.attr.orgs) {
          this.updateOrgVersions(model, changes);
        }
        if (changes.attr.isDefault) {
          this.updateIsDefault(model, changes);
        }
        this.invoke('commit', { silent: true });
      });
    },

    // When a version becomes the default, the current default needs
    // to stop being the default, and a changeDefault event is triggered
    // to let the menu know to update itself
    updateIsDefault: function (model) {
      var prevDefault = this.find(function (m) {
        return m.get('assignment.isDefault') && m.id != model.id;
      });
      if (prevDefault) {
        prevDefault.get('assignment').set('isDefault', false);
        this.trigger('changeDefault');
      }
    },

    // When a version's orgs are changed, remove any newly added
    // orgs from other versions (no org can be assigned to more than
    // one version).
    updateOrgVersions: function (model, changes) {
      var newOrgs = _.reject(changes.attr.orgs, function (org) {
        return _.contains(changes.prev.orgs, org);
      });
      if (newOrgs.length > 0) {
        _(this.reject(function (m) { return m.id === model.id; }))
          .each(function (m) {
            m.get('assignment').get('orgs').remove(newOrgs);
          });
      }
      this.trigger('changeOrgs');
    },

    url: function () {
      return '/api/internal/apps/' + this.getAppId() + '/appVersions';
    },

    getAppId: function () {
      return this.appId;
    },

    setAppId: function (appId) {
      this.appId = appId;
    },

    fetchUnused: function () {
      this.fetch({data: {includeUnused: true}});
    }

  });

  return {
    model: AppVersion,
    collection: AppVersions
  };

});
