define([
  'jquery',
  'underscore',
  'shared/models/BaseCollection',
  'shared/models/BaseModel',
  'vendor/lib/json2'
], function ($, _, BaseCollection, BaseModel) {

  // We want to be able to post the messageId for
  // creating a new message, and use that same
  // messageId for delete.  So using a private
  // var as idAttribute that only gets set prior
  // to destroy.  If messageId was used, it'd do a
  // put instead of a post.
  var UserMessage = BaseModel.extend({
    defaults: {
      messageId: undefined
    },
    idAttribute: '__messageId__',
    destroy: function () {
      this.set('__messageId__', this.get('messageId'));
      return BaseModel.prototype.destroy.apply(this, arguments);
    }
  });

  var UserMessages = BaseCollection.extend({
    model: UserMessage,
    url: '/api/internal/user-message',
    sync: function (method, collection, options) {
      /* global okta */
      if (method === 'read' && typeof okta !== 'undefined' && okta.messages) {
        var deferred = $.Deferred();
        var data = _.map(okta.messages, function (message) {
          return {messageId: message};
        });
        _.defer(function () {
          options.success(data);
          deferred.resolve();
        });
        return deferred.promise();
      }
      return BaseCollection.prototype.sync.apply(this, arguments);
    }
  });

  return {
    Model: UserMessage,
    Collection: UserMessages,
    batchSaveMessages: function (usrMssgs) {
      $.ajax({
        url: '/api/internal/user-message/batch',
        type: 'POST',
        contentType: 'application/json',
        dataType: 'json',
        data: JSON.stringify(usrMssgs) //'[{"messageId": "message"}]'
      });
    }
  };
});
