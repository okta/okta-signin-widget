define(['underscore', 'shared/util/GroupPushStatus', 'shared/models/BaseCollection',
        'shared/models/BaseModel', 'vendor/lib/json2'],
function (_, GroupPushStatus, BaseCollection, BaseModel) {

  function getAttributes(model) {
    var attrs = model.toJSON();
    attrs['searchExpression'] || delete attrs['searchExpressionType'];
    attrs['descriptionSearchExpression'] || delete attrs['descriptionSearchExpressionType'];
    return attrs;
  }

  var Rule = BaseModel.extend({
    idAttribute: 'mappingRuleId',
    defaults: {
      name: undefined,
      searchExpression: undefined,
      searchExpressionType: undefined,
      descriptionSearchExpression: undefined,
      descriptionSearchExpressionType: undefined,
      status: GroupPushStatus.ACTIVE,
      sourceAppInstanceId: undefined
    },
    initialize: function () {
      // two way bindinding for `__active__` and `status` fields
      this.on('change:__active__ change:status', function () {
        this.hasChanged('__active__') && this.set('status', this.get('__active__') ?
                                                            GroupPushStatus.ACTIVE : GroupPushStatus.INACTIVE);
        this.hasChanged('status') && this.set('__active__', this.get('status') === GroupPushStatus.ACTIVE);
      }, this);
      this.set('__active__', this.get('status') === GroupPushStatus.ACTIVE);
    },
    /* eslint complexity: [2, 7] */
    sync: function (method, model, options) {

      switch (method) {
      case 'create':
        options.attrs = getAttributes(model);
        break;
      case 'update':
        options.attrs = _(getAttributes(model)).pick(
          'name',
          'searchExpression',
          'searchExpressionType',
          'descriptionSearchExpression',
          'descriptionSearchExpressionType',
          'status'
        );
        break;
      case 'delete':
        var action = options.deleteMappings ? 'DELETE_MAPPINGS_AND_DELETE_APP_GROUPS' : 'KEEP_MAPPINGS';
        options.data = JSON.stringify({
          action: action
        });
        options.contentType = 'application/json';
        break;
      }
      return BaseModel.prototype.sync.call(this, method, model, options);
    }
  });

  var Rules = BaseCollection.extend({
    model: Rule,
    initialize: function (models, options) {
      if (!(options && options['instanceId'])) {
        throw new Error('Missing Arguments');
      }
      this.instanceId = options['instanceId'];
    },
    url: function () {
      return '/api/internal/instance/' + this.instanceId + '/grouppushrules';
    }
  });

  return {
    Model: Rule,
    Collection: Rules
  };

});
