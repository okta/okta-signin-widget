define([
  'underscore',
  'shared/util/StringUtil',
  'shared/models/BaseCollection',
  'shared/models/BaseModel'
],
  function (
    _,
    StringUtil,
    BaseCollection,
    BaseModel
  ) {

    var loc = StringUtil.localize;

    var Filters = {
      EVERYONE: {
        name: 'EVERYONE',
        title: loc('people.filters.everyone.title') //'Everyone'
      },
      ACTIVATED: {
        name: 'ACTIVATED',
        title: loc('people.filters.activated.title') //'Activated'
      },
      PENDING: {
        name: 'PENDING',
        title: loc('people.filters.pending.title') //'Pending Activation'
      },
      PASSWORD_RESET: {
        name: 'PASSWORD_RESET',
        title: loc('people.filters.passwordReset.title') //'Password Reset'
      },
      PASSWORD_EXPIRED: {
        name: 'PASSWORD_EXPIRED',
        title: loc('people.filters.passwordExpired.title') //'Password Expired'
      },
      DEACTIVATED: {
        name: 'DEACTIVATED',
        title: loc('people.filters.deactivated.title') //'Deactivated'
      },
      LOCKED_OUT: {
        name: 'LOCKED_OUT',
        title: loc('people.filters.lockedOut.title') //'Locked out'
      },
      LAST_30: {
        name: 'last30',
        title: loc('people.filters.last30.title') //'Added in last 30 days'
      },
      SUSPENDED: {
        name: 'SUSPENDED',
        title: loc('people.filters.suspended.title') //'Suspended'
      }
    };

    // These are the only ones we care about for now. Check Login.java for other possible values.
    var LoginStatuses = {
      ACTIVE: 'ACTIVE',
      PASSWORD_RESET: 'PASSWORD_RESET'
    };

    var Person = BaseModel.extend({
      defaults: {
        'id': null,
        'firstName': null,
        'lastName': null,
        'login': null,
        'email': null,
        'status': null
      }
    });

    var People = BaseCollection.extend({
      model: Person,

      url: '/api/internal/people',

      parse: function (response, options) {
        this.setPagination(response.offset > 0 && {offset: response.offset}, {fromFetch: true});

        // OKTA-21134: The way we calculate password reset is different when we generate this list vs. what is
        // returned as the status. The current workaround (more details in jira) is to filter these rows out here
        // in the UI.
        if (options.data.filter === Filters.PASSWORD_RESET.name) {
          return _.where(response.personList, {statusCode: LoginStatuses.PASSWORD_RESET});
        }

        return response.personList;
      }

    });

    return {
      Model: Person,
      Collection: People,
      Filters: Filters,
      LoginStatuses: LoginStatuses
    };
  });
